
#import "Array";
#import "GLFW";
#import "OpenGL";
#import "LibC";
#import "Basic";

#load "render.jyu";
#load "obj_loader.jyu";
// #load "NBT.jyu";

let COMPONENT_IS_INACTIVE: uint8 = (1 << 0);

var renderer: Renderer; // maybe this should be managed in render, code outside render shouldn't see it ?

var shader_default: Shader;

struct Scene {
    var root: *Entity;
}

struct Entity {
    var children: [..] *Entity;

    var position: Vector3;
    var model: *Model;
}

func render_entity_and_children(e: *Entity, local_to_world: Matrix4, override_shader: *Shader) {
    if e.model {
        var shader = *shader_default;
        if override_shader {
            shader = override_shader;
        }

        var local_transform = Matrix4.translate(e.position);
        var final_transform = Matrix4.multiply(local_transform, local_to_world);

        use_shader(*renderer, shader, final_transform);
        render_model(e.model);
    }
}

func render_scene(scene: Scene) {
    var world_offset = Matrix4.identity();
    render_entity_and_children(scene.root, world_offset, null);
}

func main(argc: int32, argv: **uint8) {

    var is_run_as_metaprogram = false;
    for 0..argc-1 {
        var s: string;
        s.data = argv[it];
        s.length = cast() strlen(s.data);

        if s == "meta" {
            is_run_as_metaprogram = true;
        }
    }

    // If we're run as a metaprogram, assume build.jyu has changed directory to the run_tree.
    // @Cleanup UnaryNot
    if is_run_as_metaprogram == false {
        var exe_path = get_executable_path();
        set_working_directory(basename(exe_path));
    }
    
    glfwInit();

    glfwWindowHint (GLFW_CONTEXT_VERSION_MAJOR, 3);
    glfwWindowHint (GLFW_CONTEXT_VERSION_MINOR, 2);
    glfwWindowHint (GLFW_OPENGL_FORWARD_COMPAT, cast() GL_TRUE);
    glfwWindowHint (GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
    
    let INITIAL_WIDTH  = 640;
    let INITIAL_HEIGHT = 480;
    
    var window = glfwCreateWindow(INITIAL_WIDTH, INITIAL_HEIGHT, "Hello, Sailor!", 0, 0);
    glfwMakeContextCurrent(window);
    
    func get_proc(name: string) -> *void {
        return glfwGetProcAddress(name.data);
    }

    init_gl_functions(get_proc);

    init(*renderer);

    var vertex_source   = read_entire_file("data/shaders/basic_light_vertex.glsl");
    var fragment_source = read_entire_file("data/shaders/basic_light_fragment.glsl");
    shader_default = compile_shader(vertex_source, fragment_source);
    
    glEnable(GL_DEPTH_TEST);
    
    var width: float = INITIAL_WIDTH;
    var height: float = INITIAL_HEIGHT;

    renderer.projection_matrix = Matrix4.perspective(90, width / height, 1, 1000);
    
    var light: Light;
    light.position = make_Vector3(10, 10, 10);
    
    array_add(*renderer.lights, light);

    var move: float = 0.0;
    var change: float = 0.001;

    var scene: Scene;
    
    var root_entity: Entity;
    var model = load_obj("data/models/monkey.obj");
    root_entity.model = *model;

    scene.root = *root_entity;
    
    while glfwWindowShouldClose(window) == false {
        glClearColor(0, 0, 0, 1);
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
        
        renderer.view_matrix = Matrix4.identity();

        move += change;
        if move > 2.0 {
            move = 2.0;
            change = -change;
        }

        if move < -2.0 {
            move = -2.0;
            change = -change;
        }

        root_entity.position = make_Vector3(move, 0, -5);
        render_scene(scene);
        
        glfwSwapBuffers(window);
        glfwPollEvents();
    }
    
    glfwTerminate();
}
