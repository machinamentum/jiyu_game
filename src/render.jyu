
struct Matrix4 {
    var m: [4][4] float;
    
    func identity() -> Matrix4 {
        var m: Matrix4;
        
        m.m[0][0] = 1;
        m.m[1][1] = 1;
        m.m[2][2] = 1;
        m.m[3][3] = 1;
        
        return m;
    }
    
    func frustum(left: float, right: float, bottom: float, top: float, _near: float, _far: float) -> Matrix4 {
        var mat: Matrix4;
        
        var A = (right + left) / (right - left);
        var B = (top + bottom) / (top - bottom);
        var C = - (_far + _near) / (_far - _near);
        var D = - (2 * _far * _near) / (_far - _near);
        
        mat.m[0][0] = 2 * _near / (right - left);
        mat.m[0][2] = A;
        
        mat.m[1][1] = 2 * _near / (top - bottom);
        mat.m[1][2] = B;
        
        mat.m[2][2] = C;
        mat.m[2][3] = D;
        
        mat.m[3][2] = -1;
        mat.m[3][3] =  0;
        return mat;
    }
    
    func translate(v: Vector3) -> Matrix4 {
        var mat: Matrix4;
        
        mat.m[0][3] = v.x;
        mat.m[1][3] = v.y;
        mat.m[2][3] = v.z;
        
        return mat;
    }
    
    func multiply(left: Matrix4, right: Matrix4) -> Matrix4 {
        var result: Matrix4;
        
        var mat = right;
        var m   = left.m;
        
        result.m[0][0] = m[0][0] * mat.m[0][0] + m[0][1] * mat.m[1][0] + m[0][2] * mat.m[2][0] + m[0][3] * mat.m[3][0];
        result.m[0][1] = m[0][0] * mat.m[0][1] + m[0][1] * mat.m[1][1] + m[0][2] * mat.m[2][1] + m[0][3] * mat.m[3][1];
        result.m[0][2] = m[0][0] * mat.m[0][2] + m[0][1] * mat.m[1][2] + m[0][2] * mat.m[2][2] + m[0][3] * mat.m[3][2];
        result.m[0][3] = m[0][0] * mat.m[0][3] + m[0][1] * mat.m[1][3] + m[0][2] * mat.m[2][3] + m[0][3] * mat.m[3][3];
        
        result.m[1][0] = m[1][0] * mat.m[0][0] + m[1][1] * mat.m[1][0] + m[1][2] * mat.m[2][0] + m[1][3] * mat.m[3][0];
        result.m[1][1] = m[1][0] * mat.m[0][1] + m[1][1] * mat.m[1][1] + m[1][2] * mat.m[2][1] + m[1][3] * mat.m[3][1];
        result.m[1][2] = m[1][0] * mat.m[0][2] + m[1][1] * mat.m[1][2] + m[1][2] * mat.m[2][2] + m[1][3] * mat.m[3][2];
        result.m[1][3] = m[1][0] * mat.m[0][3] + m[1][1] * mat.m[1][3] + m[1][2] * mat.m[2][3] + m[1][3] * mat.m[3][3];
        
        result.m[2][0] = m[2][0] * mat.m[0][0] + m[2][1] * mat.m[1][0] + m[2][2] * mat.m[2][0] + m[2][3] * mat.m[3][0];
        result.m[2][1] = m[2][0] * mat.m[0][1] + m[2][1] * mat.m[1][1] + m[2][2] * mat.m[2][1] + m[2][3] * mat.m[3][1];
        result.m[2][2] = m[2][0] * mat.m[0][2] + m[2][1] * mat.m[1][2] + m[2][2] * mat.m[2][2] + m[2][3] * mat.m[3][2];
        result.m[2][3] = m[2][0] * mat.m[0][3] + m[2][1] * mat.m[1][3] + m[2][2] * mat.m[2][3] + m[2][3] * mat.m[3][3];
        
        result.m[3][0] = m[3][0] * mat.m[0][0] + m[3][1] * mat.m[1][0] + m[3][2] * mat.m[2][0] + m[3][3] * mat.m[3][0];
        result.m[3][1] = m[3][0] * mat.m[0][1] + m[3][1] * mat.m[1][1] + m[3][2] * mat.m[2][1] + m[3][3] * mat.m[3][1];
        result.m[3][2] = m[3][0] * mat.m[0][2] + m[3][1] * mat.m[1][2] + m[3][2] * mat.m[2][2] + m[3][3] * mat.m[3][2];
        result.m[3][3] = m[3][0] * mat.m[0][3] + m[3][1] * mat.m[1][3] + m[3][2] * mat.m[2][3] + m[3][3] * mat.m[3][3];
        
        return result;
    }
}

struct Renderer {
    var global_vao_handle: GLuint;
    
    var perspective_matrix: Matrix4;
    var view_matrix: Matrix4;
}

func init(renderer: *Renderer) {
    glGenVertexArrays(1, *renderer.global_vao_handle);
    glBindVertexArray(renderer.global_vao_handle);
    
    
}

let ATTRIB_POSITION : GLuint = 0;
let ATTRIB_NORMAL   : GLuint = 1;
let ATTRIB_TEX_COORD: GLuint = 2;

struct Vector3 {
    var x: float;
    var y: float;
    var z: float;
}

func make_Vector3(x: float, y: float, z: float) -> Vector3 {
    var v: Vector3;
    v.x = x;
    v.y = y;
    v.z = z;
    return v;
}

struct Model {
    var vbo_handle: GLuint;
    var is_dirty: bool = true;
    
    var vertices:   [..] Vector3;
    var normals:    [..] Vector3;
    var tex_coords: [..] Vector3;
}

struct Shader {
    var handle: GLuint;
}

func use_shader(renderer: *Renderer, sh: *Shader) {
    glUseProgram(sh.handle);
    
    
}

func compile_shader_source(_source: string, type: GLenum) -> GLuint {
    var source = _source;

    var v = glCreateShader(type);

    var length: GLint = cast(GLint) source.length;
    glShaderSource(v, 1, *source.data, *length);
    glCompileShader(v);

    var status: GLint;
    glGetShaderiv(v, GL_COMPILE_STATUS, *status);

    if status == cast(GLint) GL_FALSE {
        var len: GLint;
        glGetShaderiv(v, GL_INFO_LOG_LENGTH, *len);
        var buf = cast(*uint8) malloc(len);

        glGetShaderInfoLog(v, len, *len, buf);
        printf("ERROR: %.*s\n".data, len, buf);

        free(buf);

        glDeleteShader(v);
        return 0;
    }

    return v;
}

func compile_shader (vertex: string, pixel: string) -> Shader {
    var vert = compile_shader_source(vertex, GL_VERTEX_SHADER);
    var frag = compile_shader_source(pixel,  GL_FRAGMENT_SHADER);
    
    var out: Shader;

    if vert == 0 || frag == 0 {
        glDeleteShader(vert);
        glDeleteShader(frag);
        return out;
    }

    var program = glCreateProgram();
    glAttachShader(program, vert);
    glAttachShader(program, frag);
    glLinkProgram(program);

    var status: GLint;
    glGetProgramiv(program, GL_LINK_STATUS, *status);
    if (status == cast(GLint) GL_FALSE) {
        var len: GLint;
        glGetProgramiv(program, GL_INFO_LOG_LENGTH, *len);
        var buf = cast(*uint8) malloc(len);
        glGetProgramInfoLog(program, cast() len, cast() *len, buf);
        printf("ERROR: %.*s\n".data, len, buf);
        free(buf);

        glDeleteProgram(program);
        glDeleteShader(vert);
        glDeleteShader(frag);

        out.handle = 0;
        return out;
    }

    glDetachShader(program, vert);
    glDetachShader(program, frag);

    out.handle = program;
    return out;
}

func cache_to_vertex_buffer(model: *Model) {
    if model.vbo_handle == 0 {
        glGenBuffers(1, *model.vbo_handle);
    }
    
    if model.is_dirty == false {
        return;
    }
    
    var vert_size   = model.vertices.count*sizeof(Vector3);
    var normal_size = model.normals.count*sizeof(Vector3);
    var tex_size    = model.tex_coords.count*sizeof(Vector3);
    
    var total_size = vert_size+normal_size+tex_size;
    
    glBindBuffer(GL_ARRAY_BUFFER, model.vbo_handle);
    glBufferData(GL_ARRAY_BUFFER, cast(GLsizei) total_size, null, GL_STATIC_DRAW);
    
    glBufferSubData(GL_ARRAY_BUFFER, 0,         vert_size,   model.vertices.data);
    glBufferSubData(GL_ARRAY_BUFFER, vert_size, normal_size, model.normals.data);
    glBufferSubData(GL_ARRAY_BUFFER, vert_size+normal_size, tex_size, model.tex_coords.data);
    
    glBindBuffer(GL_ARRAY_BUFFER, 0);
    
    model.is_dirty = false;
}

func render_model(model: *Model) {
    cache_to_vertex_buffer(model);
    
    /*
    glBegin(GL_TRIANGLES);
    for 0..model.vertices.count-1 {
        var v = model.vertices[it];
        var n = model.normals[it];
        glVertex3f(v.x, v.y, v.z);
        glNormal3f(n.x, n.y, n.z);
    }
    glEnd();
    */
    
    glBindBuffer(GL_ARRAY_BUFFER, model.vbo_handle);
    glEnableVertexAttribArray(ATTRIB_POSITION);
    glEnableVertexAttribArray(ATTRIB_NORMAL);
    
    var vert_size   = model.vertices.count*sizeof(Vector3);
    var normal_size = model.normals.count*sizeof(Vector3);
    var tex_size    = model.tex_coords.count*sizeof(Vector3);
    
    glVertexAttribPointer(ATTRIB_POSITION, 3, GL_FLOAT, GL_FALSE, sizeof(Vector3), cast(*void) 0);
    glVertexAttribPointer(ATTRIB_NORMAL,   3, GL_FLOAT, GL_FALSE, sizeof(Vector3), cast(*void) vert_size);
    
    glDrawArrays(GL_TRIANGLES, 0, cast(GLint) model.vertices.count);
    
    glDisableVertexAttribArray(ATTRIB_POSITION);
    glDisableVertexAttribArray(ATTRIB_NORMAL);
}
