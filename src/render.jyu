#import "Math";

struct Renderer {
    var global_vao_handle: GLuint;

    var projection_matrix: Matrix4;
    var view_matrix: Matrix4;

    var lights: [..] Light;
}

struct Light {
    var position: Vector3;
}

func init(renderer: *Renderer) {
    glGenVertexArrays(1, *renderer.global_vao_handle);
    glBindVertexArray(renderer.global_vao_handle);
}

let ATTRIB_POSITION : GLuint = 0;
let ATTRIB_NORMAL   : GLuint = 1;
let ATTRIB_TEX_COORD: GLuint = 2;

func make_Vector3(x: float, y: float, z: float) -> Vector3 {
    return Vector3.make(x, y, z);
}

struct Model {
    var vbo_handle: GLuint;
    var is_dirty: bool = true;

    var vertices:   [..] Vector3;
    var normals:    [..] Vector3;
    var tex_coords: [..] Vector3;
}

struct Shader {
    var handle: GLuint;
}

func use_shader(renderer: *Renderer, sh: *Shader, model_matrix: Matrix4) {
    glUseProgram(sh.handle);

    var proj  = glGetUniformLocation(sh.handle, "projection");
    var view  = glGetUniformLocation(sh.handle, "view");
    var model = glGetUniformLocation(sh.handle, "model");

    glUniformMatrix4fv(proj, 1, GL_TRUE, cast() renderer.projection_matrix.m.data);
    glUniformMatrix4fv(view, 1, GL_TRUE, cast() renderer.view_matrix.m.data);

    glUniformMatrix4fv(model, 1, GL_TRUE, cast() model_matrix.m.data);

    for 0..renderer.lights.count-1 {
        var light = *renderer.lights[it];
        // @Incomplete
        var position = glGetUniformLocation(sh.handle, "lights[0].position");

        glUniform3fv(position, 1, cast(*GLfloat) *light.position);
    }
}

func compile_shader_source(_source: string, type: GLenum) -> GLuint {
    var source = _source;

    var v = glCreateShader(type);
    
    var source_datas: [..] *uint8;
    var source_lengths: [..] GLint;

    #if os(MacOSX) {
        let VERSION_STRING = "#version 330 core";
    } else {
        let VERSION_STRING = "#version 300 es\nprecision highp float;\n";
    }

    source_datas.add(VERSION_STRING.data);
    source_lengths.add(cast(GLint) VERSION_STRING.length);

    source_datas.add(source.data);
    source_lengths.add(cast(GLint) source.length);

    glShaderSource(v, cast() source_datas.count, source_datas.data, source_lengths.data);
    glCompileShader(v);

    source_datas.reset();
    source_lengths.reset();

    var status: GLint;
    glGetShaderiv(v, GL_COMPILE_STATUS, *status);

    if status == cast(GLint) GL_FALSE {
        var len: GLint;
        glGetShaderiv(v, GL_INFO_LOG_LENGTH, *len);
        var buf = cast(*uint8) malloc(cast(size_t) len);

        glGetShaderInfoLog(v, len, *len, buf);
        printf("ERROR: %.*s\n", len, buf);

        free(buf);

        glDeleteShader(v);
        return 0;
    }

    return v;
}

func compile_shader(vertex: string, pixel: string) -> Shader {
    var vert = compile_shader_source(vertex, GL_VERTEX_SHADER);
    var frag = compile_shader_source(pixel,  GL_FRAGMENT_SHADER);

    var out: Shader;

    if vert == 0 || frag == 0 {
        glDeleteShader(vert);
        glDeleteShader(frag);
        return out;
    }

    var program = glCreateProgram();
    glAttachShader(program, vert);
    glAttachShader(program, frag);
    glLinkProgram(program);

    var status: GLint;
    glGetProgramiv(program, GL_LINK_STATUS, *status);
    if (status == cast(GLint) GL_FALSE) {
        var len: GLint;
        glGetProgramiv(program, GL_INFO_LOG_LENGTH, *len);
        var buf = cast(*uint8) malloc(cast(size_t) len);
        glGetProgramInfoLog(program, cast() len, cast() *len, buf);
        printf("ERROR: %.*s\n", len, buf);
        free(buf);

        glDeleteProgram(program);
        glDeleteShader(vert);
        glDeleteShader(frag);

        out.handle = 0;
        return out;
    }

    glDetachShader(program, vert);
    glDetachShader(program, frag);

    out.handle = program;
    return out;
}

func cache_to_vertex_buffer(model: *Model) {
    if model.vbo_handle == 0 {
        glGenBuffers(1, *model.vbo_handle);
    }

    // @Cleanup UnaryNot
    if model.is_dirty == false {
        return;
    }

    var vert_size   = model.vertices.count*sizeof(Vector3);
    var normal_size = model.normals.count*sizeof(Vector3);
    var tex_size    = model.tex_coords.count*sizeof(Vector3);

    var total_size = vert_size+normal_size+tex_size;

    glBindBuffer(GL_ARRAY_BUFFER, model.vbo_handle);
    glBufferData(GL_ARRAY_BUFFER, cast(GLsizei) total_size, null, GL_STATIC_DRAW);

    glBufferSubData(GL_ARRAY_BUFFER, 0,         vert_size,   model.vertices.data);
    glBufferSubData(GL_ARRAY_BUFFER, vert_size, normal_size, model.normals.data);
    glBufferSubData(GL_ARRAY_BUFFER, vert_size+normal_size, tex_size, model.tex_coords.data);

    glBindBuffer(GL_ARRAY_BUFFER, 0);

    model.is_dirty = false;
}

func render_model(model: *Model) {
    cache_to_vertex_buffer(model);

    glBindBuffer(GL_ARRAY_BUFFER, model.vbo_handle);
    glEnableVertexAttribArray(ATTRIB_POSITION);
    glEnableVertexAttribArray(ATTRIB_NORMAL);

    var vert_size   = model.vertices.count*sizeof(Vector3);
    var normal_size = model.normals.count*sizeof(Vector3);
    var tex_size    = model.tex_coords.count*sizeof(Vector3);

    glVertexAttribPointer(ATTRIB_POSITION, 3, GL_FLOAT, GL_FALSE, sizeof(Vector3), cast(*void) 0);
    glVertexAttribPointer(ATTRIB_NORMAL,   3, GL_FLOAT, GL_FALSE, sizeof(Vector3), cast(*void) vert_size);

    glDrawArrays(GL_TRIANGLES, 0, cast(GLint) model.vertices.count);

    glDisableVertexAttribArray(ATTRIB_POSITION);
    glDisableVertexAttribArray(ATTRIB_NORMAL);
}
